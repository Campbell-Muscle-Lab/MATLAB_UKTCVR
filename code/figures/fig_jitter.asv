function fig_jitter(t, data_label, f1_label, options)
% Make a jitter figure

    arguments
        t (:,:) table
        data_label (1,1) string
        f1_label (1,1) string

        options.f2_label (1,1) string = ""
        options.grouping_label (1,1) string = ""
        options.figure_handle (1,1) double = 1
        options.subplot_handle (1,1) double = 0
        
        options.f2_spacing = 1

        options.marker_size (1,:) double = 40

        options.symbols (1,:) string = ["o", "s", "v", "^", "<", ">", "p"]
        options.group_colors logical = false
        options.color_map (:,:) double = []
        options.alpha = 0.1
        options.XJitterWidth = 0.5
        options.edge_width = 0.5
        options.edge_brightening = -0.5

        options.draw_y_from_zero = false
        options.y_ticks (:,:) double = []

        options.super_plot logical = true
        options.super_plot_size_offset double = 40;
        options.super_plot_XJitterWidth = 0.2;
        options.super_plot_alpha = 0.7;

        options.join_points = false
        options.join_line_width = 1
        options.join_line_color (1,:) double = [0 0 0]

        options.f1_font_size = 12
        options.f1_label_rotation = 45
        options.f1_vertical_offset = -0.1
        
        options.f2_font_size = 12
        options.f2_label_rel_pos = -0.5
        
        options.title_string (1,1) string = ""
        options.title_font_size = 12
        options.title_rel_y_pos (1,1) double = 1.7
        options.title_text_interpreter (1,1) = "tex"

        options.post_hoc_table (:,:) table = []
        options.post_hoc_font_size (1,1) double = 10
        options.post_hoc_rel_y_spacing (1,1) double = 0.15
    end

    % Code

    % Set the color_map if necessary
    if (isempty(options.color_map))
        options.color_map = return_matplotlib_default_colors();
    end

    % Set the edge colors
    edge_colors = brighten(options.color_map, options.edge_brightening);

    % Make the figure if necessary
    if ((options.subplot_handle ~= 0) || ...
            (options.figure_handle ~= 0))

        if (options.subplot_handle ~= 0)
            subplot(options.subplot_handle);
            hold on;
        else
            figure(options.figure_handle);
            clf
            sp = layout_subplots( ...
                    padding_top = 2, ...
                    padding_left = 1, ...
                    padding_right = 0.5, ...
                    padding_bottom = 1);
            subplot(sp(1));
            hold on;
         end
    end

    % Extract the data
    jd = table_to_jitter_format(t, data_label, f1_label, ...
            f2_label = options.f2_label, ...
            grouping_label = options.grouping_label);

    % Work out number of f1 and f2 categories
    no_of_f1_cats = 0;
    no_of_f2_cats = numel(jd);
    for f2 = 1 : no_of_f2_cats
        no_of_f1_cats = max([no_of_f1_cats numel(jd(f2).points)]);
    end

    % Create matrices for swarm plot, building up labels as we go
    x_anchor = 1;
    x = [];
    y = [];
    g = [];

    f1_x_start = [];
    f1_x_end = [];

    f1_ticks.x = [];
    f1_ticks.labels = [];
    f1_ticks.f1f2_labels = [];

    f2_ticks.x = [];
    f2_ticks.labels =[];

    % Some prep work
    if (no_of_f2_cats > 1)
        f2_v = jd.f2_values;
    end

    for f2_i = 1 : no_of_f2_cats
        
        % Note for tick positions
        f1_x_start = x_anchor;        

        for f1_i = 1 : no_of_f1_cats
            try
                y_temp = jd(f2_i).points{f1_i};
            catch
                x_anchor = x_anchor + 1
                continue;
            end
            x = [x ; x_anchor * ones(numel(y_temp), 1)];
            y = [y ; y_temp];
            if (options.grouping_label ~= "")
                g = [g ; jd(f2_i).group{f1_i}];
            end

            % And now ticks
            f1_ticks.x = [f1_ticks.x x_anchor];
            f1_v = jd.f1_values;
            f1_ticks.labels = [f1_ticks.labels f1_v(f1_i)];
            if (no_of_f2_cats > 1)
                f1_ticks.f1f2_labels = [f1_ticks.f1f2_labels ...
                    string(sprintf('%s:%s', f1_v(f1_i), f2_v(f2_i)))];
            else
                f1_ticks.f1f2_labels = f1_ticks.labels;
            end

            x_anchor = x_anchor + 1;
        end

        f1_x_end = x_anchor - 1;

        if (f2_i < no_of_f2_cats)
            x_anchor = x_anchor + options.f2_spacing;
        end

        if (no_of_f2_cats > 1)
            f2_ticks.x = [f2_ticks.x mean([f1_x_start f1_x_end])];
            f2_ticks.labels = [f2_ticks.labels f2_v(f2_i)];
        end
    end
    
    % Set the group indices
    if (isempty(g))
        % If grouping wasn't set, everything is the same group
        g = ones(size(y));
    else
        g = grp2idx(g);
    end

    % Turn the group index into symbol indices, noting the finite number
    % of symbols
    si = mod(g, numel(options.symbols));
    si(si==0) = numel(options.symbols);

    % Use the f1_labels to get column colors
    col_ci = grp2idx(f1_ticks.labels);

    % Reset superplot structure
    super_plot.x = [];
    super_plot.y = [];
    super_plot.g = [];
    super_plot.symbol_index = [];
    super_plot.color_index = [];

    % Now plot
    for gi = 1 : max(g)

        % Find the points for the group
        vi = find(g == gi);

        % Set the symbol
        symbol_index = si(vi(1));

        % Plot unique x values separately so that you can give
        % columns different colors
        unique_x = unique(x(vi));

        for i = 1 : numel(unique_x)

            % Find the points for each value of x
            vix = find(x(vi) == unique_x(i));
            vix = vi(vix);

            % Now get the color
            if (~isempty(options.group_colors))
                % Plot by f1
                ci = find(f1_ticks.x == unique_x(i));
                color_index = col_ci(ci);
            end

            if (options.marker_size > 0)
                swarmchart(x(vix), y(vix), ...
                    options.marker_size, ...
                    options.symbols(symbol_index), ...
                    'filled', ...
                    MarkerFaceColor = options.color_map(color_index, :), ...
                    MarkerEdgeColor = edge_colors(color_index, :), ...
                    LineWidth = options.edge_width, ...
                    XJitter = 'density', ...
                    XJitterWidth = options.XJitterWidth, ...
                    MarkerFaceAlpha = options.alpha);
            end

            if (options.super_plot)
                % Hold the mean data so that we can plot it later
                super_plot.x = [super_plot.x x(vix(1))];
                super_plot.y = [super_plot.y mean(y(vix))];
                super_plot.g = [super_plot.g gi];
                super_plot.symbol_index = [super_plot.symbol_index symbol_index];
                super_plot.color_index = [super_plot.color_index color_index];
            end
        end
    end

    if (options.super_plot)
        % Now we have plotted all the symbols, circle back and do the group
        % means - these have to be plotted separately for each symbol and
        % color combination
        unique_symb = unique(super_plot.symbol_index);
        unique_cols = unique(super_plot.color_index);
    
        for si = 1 : numel(unique_symb)
            for ci = 1 : numel(unique_cols)
                vi = find( (super_plot.symbol_index == unique_symb(si)) & ...
                        (super_plot.color_index == unique_cols(ci)) );
    
                swarmchart(super_plot.x(vi), super_plot.y(vi), ...
                    options.marker_size + options.super_plot_size_offset, ...
                    options.symbols(unique_symb(si)), ...
                    'filled', ...
                    MarkerFaceColor = options.color_map(ci, :), ...
                    MarkerEdgeColor = edge_colors(ci, :), ...
                    LineWidth = options.edge_width, ...
                    XJitter = 'density', ...
                    XJitterWidth = options.super_plot_XJitterWidth, ...
                    MarkerFaceAlpha = options.super_plot_alpha);
            end
        end

        % Now see if we need to join points
        if (options.join_points)

            unique_g = unique(super_plot.g);

            for gi = 1 : numel(unique_g)
                vi = find(super_plot.g == unique_g(gi));
                plot(super_plot.x(vi), super_plot.y(vi), ...
                    '-', ...
                    Color = options.join_line_color, ...
                    LineWidth = options.join_line_width);
            end
        end

    end

    % Work out whether we want to draw y-axis from 0
    if (options.draw_y_from_zero) || (min(y) < (0.8 * max(y)))
        y_lim = ylim;
        y_ticks = [0 y_lim(end)];
    end

    if (isempty(options.y_ticks))

    % Now format
    axes_data = improve_axes( ...
        x_tick_label_positions = f1_ticks.x, ...
        x_tick_labels = strrep(f1_ticks.labels, '_', ' '), ...
        x_tick_label_rotation = options.f1_label_rotation, ...
        x_tick_label_vertical_offset = options.f1_vertical_offset, ...
        x_tick_label_font_size = options.f1_font_size, ...
        x_axis_label =  "", ...
        y_axis_label = data_label, ...
        y_ticks = options.y_ticks, ...
        title = options.title_string, ...
        title_font_size = options.title_font_size, ...
        title_y_offset = options.title_rel_y_pos, ...
        title_text_interpreter = options.title_text_interpreter);

    for i = 1 : numel(f2_ticks.x)
        text(f2_ticks.x(i), ...
                axes_data.y_ticks(1) + ...
                    (options.f2_label_rel_pos * diff(axes_data.y_ticks)), ...
                f2_ticks.labels(i), ...
                HorizontalAlignment = 'center', ...
                FontSize = options.f2_font_size);
    end

    % Finally, add in the post_hoc effects
    if (~isempty(options.post_hoc_table))
        pht = options.post_hoc_table;

        % Find signifcant entries
        vi = find(pht.p_corrected < 0.05)
        for i = 1 : numel(vi)
            vi_a = find(f1_ticks.f1f2_labels == pht.varname_1(i));
            vi_b = find(f1_ticks.f1f2_labels == pht.varname_2(i));

            pht.x1(i) = f1_ticks.x(vi_a);
            pht.x2(i) = f1_ticks.x(vi_b);
        end

        stat_lines(pht, axes_data, ...
            font_size = options.post_hoc_font_size, ...
            rel_y_spacing = options.post_hoc_rel_y_spacing)
    end
